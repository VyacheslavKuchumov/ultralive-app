#!/usr/bin/env python3

"""Generate .env file for release XMPP bot container."""

from __future__ import annotations

import argparse
import sys
from datetime import datetime, timezone
from pathlib import Path


def bare_jid(value: str) -> str:
    return value.split("/", 1)[0].strip().lower()


def infer_server_from_jid(jid: str) -> str:
    bare = bare_jid(jid)
    if "@" not in bare:
        raise ValueError("JID must have @domain, e.g. ultralive-release-bot@vyachik-dev.ru")
    return bare.split("@", 1)[1]


def build_env_text(args: argparse.Namespace) -> str:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")
    xmpp_server = args.xmpp_server or infer_server_from_jid(args.jid)

    allowed_senders = [bare_jid(value) for value in args.allowed_sender]
    if not allowed_senders:
        raise ValueError("At least one --allowed-sender must be provided")

    lines = [
        "# Auto-generated by scripts/generate_release_bot_env.py",
        f"# Generated at {timestamp}",
        "",
        f"XMPP_JID={bare_jid(args.jid)}",
        f"XMPP_PASSWORD={args.password}",
        f"XMPP_SERVER={xmpp_server}",
        f"XMPP_PORT={args.xmpp_port}",
        f"XMPP_RESOURCE={args.xmpp_resource}",
        f"XMPP_ALLOWED_SENDERS={','.join(allowed_senders)}",
        "",
        f"HOST_REPO_PATH={args.host_repo_path}",
        f"REPO_PATH={args.repo_path}",
        "",
        f"DEPLOY_REMOTE={args.deploy_remote}",
        f"DEPLOY_BRANCH={args.deploy_branch}",
        f"DEPLOY_COMPOSE_FILE={args.deploy_compose_file}",
        "",
        f"BOT_REPLY_MAX_CHARS={args.bot_reply_max_chars}",
        "",
    ]
    return "\n".join(lines)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate .env.release-bot for XMPP release bot."
    )
    parser.add_argument(
        "--output",
        default=".env.release-bot",
        help="Path to output env file (default: .env.release-bot)",
    )
    parser.add_argument(
        "--jid",
        required=True,
        help="Bot JID, for example ultralive-release-bot@vyachik-dev.ru",
    )
    parser.add_argument(
        "--password",
        required=True,
        help="Password for bot XMPP account",
    )
    parser.add_argument(
        "--allowed-sender",
        action="append",
        required=True,
        help="Authorized sender JID (repeat option for multiple senders)",
    )
    parser.add_argument(
        "--host-repo-path",
        required=True,
        help="Absolute path to ultralive-app-v2 on VPS host",
    )
    parser.add_argument(
        "--repo-path",
        default="/workspace",
        help="Repo path inside bot container (default: /workspace)",
    )
    parser.add_argument(
        "--xmpp-server",
        default="",
        help="XMPP server host (default: inferred from JID domain)",
    )
    parser.add_argument(
        "--xmpp-port",
        type=int,
        default=5222,
        help="XMPP server port (default: 5222)",
    )
    parser.add_argument(
        "--xmpp-resource",
        default="release-bot",
        help="XMPP resource for bot session",
    )
    parser.add_argument(
        "--deploy-remote",
        default="origin",
        help="Git remote for deploy updates",
    )
    parser.add_argument(
        "--deploy-branch",
        default="main",
        help="Git branch for deploy updates",
    )
    parser.add_argument(
        "--deploy-compose-file",
        default="",
        help="Optional compose file path relative to repo root",
    )
    parser.add_argument(
        "--bot-reply-max-chars",
        type=int,
        default=3000,
        help="Max characters per XMPP message chunk",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing output file",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    output_path = Path(args.output)

    if output_path.exists() and not args.force:
        print(
            f"Refusing to overwrite existing file: {output_path}\nUse --force to overwrite.",
            file=sys.stderr,
        )
        return 1

    try:
        text = build_env_text(args)
    except ValueError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    output_path.write_text(text, encoding="utf-8")
    print(f"Wrote {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
